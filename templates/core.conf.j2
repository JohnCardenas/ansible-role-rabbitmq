# ======================================
# RabbitMQ broker section
# ======================================

## Related doc guide: https://rabbitmq.com/configure.html. See
## https://rabbitmq.com/documentation.html for documentation ToC.

## Networking
## ====================
##
## Related doc guide: https://rabbitmq.com/networking.html.
##
## By default, RabbitMQ will listen on all interfaces, using
## the standard (reserved) AMQP 0-9-1 and 1.0 port.
##
# listeners.tcp.default = 5672

## To listen on a specific interface, provide an IP address with port.
## For example, to listen only on localhost for both IPv4 and IPv6:
##
# IPv4
# listeners.tcp.local    = 127.0.0.1:5672
# IPv6
# listeners.tcp.local_v6 = ::1:5672

## You can define multiple listeners using listener names
# listeners.tcp.other_port = 5673
# listeners.tcp.other_ip   = 10.10.10.10:5672

## TLS listeners are configured in the same fashion as TCP listeners,
## including the option to control the choice of interface.
##
# listeners.ssl.default = 5671

{% for item in rabbitmq.config.listeners.tcp|default([]) -%}
  listeners.tcp.{{loop.index}} = {{item}}:5672
{% endfor %}
{% for item in rabbitmq.config.listeners.ssl|default([]) -%}
  listeners.ssl.{{loop.index}} = {{item}}:5671
{% endfor %}

## Number of Erlang processes that will accept connections for the TCP
## and TLS listeners.
##
# num_acceptors.tcp = 10
{% if rabbitmq.config.num_acceptors.tcp is defined -%}
  num_acceptors.tcp = {{ rabbitmq.config.num_acceptors.tcp|default(10) }}
{% endif %}
# num_acceptors.ssl = 10
{% if rabbitmq.config.num_acceptors.ssl is defined -%}
  num_acceptors.ssl = {{ rabbitmq.config.num_acceptors.ssl|default(10) }}
{% endif %}

## Maximum amount of time allowed for the AMQP 0-9-1 and AMQP 1.0 handshake
## (performed after socket connection and TLS handshake) to complete, in milliseconds.
##
# handshake_timeout = 10000
{% if rabbitmq.config.handshake_timeout is defined -%}
  handshake_timeout = {{ rabbitmq.config.handshake_timeout|default(10000) }}
{% endif %}

## Set to 'true' to perform reverse DNS lookups when accepting a
## connection. rabbitmqctl and management UI will then display hostnames
## instead of IP addresses. Default value is `false`.
##
# reverse_dns_lookups = false
{% if rabbitmq.config.reverse_dns_lookups is defined -%}
  reverse_dns_lookups = {{ rabbitmq.config.reverse_dns_lookups|default('false') }}
{% endif %}



##
## Security, Access Control
## ==============
##

## Related doc guide: https://rabbitmq.com/access-control.html.

## The default "guest" user is only permitted to access the server
## via a loopback interface (e.g. localhost).
## {loopback_users, [<<"guest">>]},
##
# loopback_users.guest = true

## Uncomment the following line if you want to allow access to the
## guest user from anywhere on the network.
# loopback_users.guest = false

{% for user in rabbitmq.config.loopback_users|default([]) -%}
  {%- for key, value in user.items() -%}
    loopback_users.{{key}} = {{value}}
  {% endfor -%}
{%- endfor %}

## TLS configuration.
##
## Related doc guide: https://rabbitmq.com/ssl.html.
##
# ssl_options.verify               = verify_peer
# ssl_options.fail_if_no_peer_cert = false
# ssl_options.cacertfile           = /path/to/cacert.pem
# ssl_options.certfile             = /path/to/cert.pem
# ssl_options.keyfile              = /path/to/key.pem
#
# ssl_options.honor_cipher_order   = true
# ssl_options.honor_ecc_order      = true

# ssl_options.ciphers.1  = ECDHE-ECDSA-AES256-GCM-SHA384
# ssl_options.ciphers.2  = ECDHE-RSA-AES256-GCM-SHA384
# ssl_options.ciphers.3  = ECDHE-ECDSA-AES256-SHA384
# ssl_options.ciphers.4  = ECDHE-RSA-AES256-SHA384
# ssl_options.ciphers.5  = ECDH-ECDSA-AES256-GCM-SHA384
# ssl_options.ciphers.6  = ECDH-RSA-AES256-GCM-SHA384
# ssl_options.ciphers.7  = ECDH-ECDSA-AES256-SHA384
# ssl_options.ciphers.8  = ECDH-RSA-AES256-SHA384
# ssl_options.ciphers.9  = DHE-RSA-AES256-GCM-SHA384
# ssl_options.ciphers.10 = DHE-DSS-AES256-GCM-SHA384
# ssl_options.ciphers.11 = DHE-RSA-AES256-SHA256
# ssl_options.ciphers.12 = DHE-DSS-AES256-SHA256
# ssl_options.ciphers.13 = ECDHE-ECDSA-AES128-GCM-SHA256
# ssl_options.ciphers.14 = ECDHE-RSA-AES128-GCM-SHA256
# ssl_options.ciphers.15 = ECDHE-ECDSA-AES128-SHA256
# ssl_options.ciphers.16 = ECDHE-RSA-AES128-SHA256
# ssl_options.ciphers.17 = ECDH-ECDSA-AES128-GCM-SHA256
# ssl_options.ciphers.18 = ECDH-RSA-AES128-GCM-SHA256
# ssl_options.ciphers.19 = ECDH-ECDSA-AES128-SHA256
# ssl_options.ciphers.20 = ECDH-RSA-AES128-SHA256
# ssl_options.ciphers.21 = DHE-RSA-AES128-GCM-SHA256
# ssl_options.ciphers.22 = DHE-DSS-AES128-GCM-SHA256
# ssl_options.ciphers.23 = DHE-RSA-AES128-SHA256
# ssl_options.ciphers.24 = DHE-DSS-AES128-SHA256
# ssl_options.ciphers.25 = ECDHE-ECDSA-AES256-SHA
# ssl_options.ciphers.26 = ECDHE-RSA-AES256-SHA
# ssl_options.ciphers.27 = DHE-RSA-AES256-SHA
# ssl_options.ciphers.28 = DHE-DSS-AES256-SHA
# ssl_options.ciphers.29 = ECDH-ECDSA-AES256-SHA
# ssl_options.ciphers.30 = ECDH-RSA-AES256-SHA
# ssl_options.ciphers.31 = ECDHE-ECDSA-AES128-SHA
# ssl_options.ciphers.32 = ECDHE-RSA-AES128-SHA
# ssl_options.ciphers.33 = DHE-RSA-AES128-SHA
# ssl_options.ciphers.34 = DHE-DSS-AES128-SHA
# ssl_options.ciphers.35 = ECDH-ECDSA-AES128-SHA
# ssl_options.ciphers.36 = ECDH-RSA-AES128-SHA

{% if rabbitmq.config.ssl_options.verify is defined -%}
  ssl_options.verify               = {{ rabbitmq.config.ssl_options.verify|default('verify_peer') }}
{% endif %}
{% if rabbitmq.config.ssl_options.fail_if_no_peer_cert is defined -%}
  ssl_options.fail_if_no_peer_cert = {{ rabbitmq.config.ssl_options.fail_if_no_peer_cert|default('false') }}
{% endif %}
{% if rabbitmq.config.ssl_options.cacertfile is defined -%}
  ssl_options.cacertfile           = {{ rabbitmq.config.ssl_options.cacertfile|default('/etc/ssl/certs/ca-bundle.crt') }}
{% endif %}
{% if rabbitmq.config.ssl_options.certfile is defined -%}
  ssl_options.certfile             = {{ rabbitmq.config.ssl_options.certfile }}
{% endif %}
{% if rabbitmq.config.ssl_options.keyfile is defined -%}
  ssl_options.keyfile              = {{ rabbitmq.config.ssl_options.keyfile }}
{% endif %}

{% if rabbitmq.config.ssl_options.honor_cipher_order is defined -%}
  ssl_options.honor_cipher_order = {{ rabbitmq.config.ssl_options.honor_cipher_order|default('true') }}
{% endif %}
{% if rabbitmq.config.ssl_options.honor_ecc_order is defined -%}
  ssl_options.honor_ecc_order    = {{ rabbitmq.config.ssl_options.honor_ecc_order|default('true') }}
{% endif %}

{% for item in rabbitmq.config.ssl_options.ciphers|default([]) -%}
  ssl_options.ciphers.{{loop.index}}  = {{item}}
{% endfor %}


## Select an authentication/authorisation backend to use.
##
## Alternative backends are provided by plugins, such as rabbitmq-auth-backend-ldap.
##
## NB: These settings require certain plugins to be enabled.
##
## Related doc guides:
##
##  * https://rabbitmq.com/plugins.html
##  * https://rabbitmq.com/access-control.html
##

# auth_backends.1   = rabbit_auth_backend_internal

## uses separate backends for authentication and authorisation,
## see below.
# auth_backends.1.authn = rabbit_auth_backend_ldap
# auth_backends.1.authz = rabbit_auth_backend_internal

## The rabbitmq_auth_backend_ldap plugin allows the broker to
## perform authentication and authorisation by deferring to an
## external LDAP server.
##
## Relevant doc guides:
##
## * https://rabbitmq.com/ldap.html
## * https://rabbitmq.com/access-control.html
##
## uses LDAP for both authentication and authorisation
# auth_backends.1 = rabbit_auth_backend_ldap

## uses HTTP service for both authentication and
## authorisation
# auth_backends.1 = rabbit_auth_backend_http

## uses two backends in a chain: HTTP first, then internal
# auth_backends.1   = rabbit_auth_backend_http
# auth_backends.2   = rabbit_auth_backend_internal

{% for item in rabbitmq.config.auth_backends|default([]) %}
auth_backends.{{loop.count}}.authn = {{item.authn}}
auth_backends.{{loop.count}}.authz = {{item.authz}}
{% endfor %}


## Authentication
## The built-in mechanisms are 'PLAIN',
## 'AMQPLAIN', and 'EXTERNAL' Additional mechanisms can be added via
## plugins.
##
## Related doc guide: https://rabbitmq.com/authentication.html.
##
# auth_mechanisms.1 = PLAIN
# auth_mechanisms.2 = AMQPLAIN

## The rabbitmq-auth-mechanism-ssl plugin makes it possible to
## authenticate a user based on the client's x509 (TLS) certificate.
## Related doc guide: https://rabbitmq.com/authentication.html.
##
## To use auth-mechanism-ssl, the EXTERNAL mechanism should
## be enabled:
##
# auth_mechanisms.1 = PLAIN
# auth_mechanisms.2 = AMQPLAIN
# auth_mechanisms.3 = EXTERNAL

## To force x509 certificate-based authentication on all clients,
## exclude all other mechanisms (note: this will disable password-based
## authentication even for the management UI!):
##
# auth_mechanisms.1 = EXTERNAL

{% for item in rabbitmq.config.auth_mechanisms|default([]) -%}
  auth_mechanisms.{{loop.count}} = {{item}}
{% endfor %}


## This pertains to both the rabbitmq-auth-mechanism-ssl plugin and
## STOMP ssl_cert_login configurations. See the RabbitMQ STOMP plugin
## configuration section later in this file and the README in
## https://github.com/rabbitmq/rabbitmq-auth-mechanism-ssl for further
## details.
##
## To use the TLS cert's CN instead of its DN as the username
##
# ssl_cert_login_from   = common_name
{% if rabbitmq.config.ssl_cert_login_from is defined -%}
  ssl_cert_login_from = {{ rabbitmq.config.ssl_cert_login_from|default('common_name') }}
{% endif %}

## TLS handshake timeout, in milliseconds.
##
# ssl_handshake_timeout = 5000
{% if rabbitmq.config.ssl_handshake_timeout is defined -%}
  ssl_handshake_timeout = {{ rabbitmq.config.ssl_handshake_timeout|default(5000) }}
{% endif %}


## Cluster name
##
# cluster_name = dev3.eng.megacorp.local
{% if rabbitmq.config.cluster_name is defined -%}
  cluster_name = {{rabbitmq.config.cluster_name}}
{% endif %}

## Password hashing implementation. Will only affect newly
## created users. To recalculate hash for an existing user
## it's necessary to update her password.
##
## To use SHA-512, set to rabbit_password_hashing_sha512.
##
# password_hashing_module = rabbit_password_hashing_sha256

## When importing definitions exported from versions earlier
## than 3.6.0, it is possible to go back to MD5 (only do this
## as a temporary measure!) by setting this to rabbit_password_hashing_md5.
##
# password_hashing_module = rabbit_password_hashing_md5

{% if rabbitmq.config.password_hashing_module is defined -%}
  password_hashing_module = {{rabbitmq.config.password_hashing_module}}
{% endif %}


##
## Default User / VHost
## ====================
##

## On first start RabbitMQ will create a vhost and a user. These
## config items control what gets created.
## Relevant doc guide: https://rabbitmq.com/access-control.html
##
# default_vhost = /
# default_user = guest
# default_pass = guest

# default_permissions.configure = .*
# default_permissions.read = .*
# default_permissions.write = .*

## Tags for default user
##
## For more details about tags, see the documentation for the
## Management Plugin at https://rabbitmq.com/management.html.
##
# default_user_tags.administrator = true

## Define other tags like this:
# default_user_tags.management = true
# default_user_tags.custom_tag = true

{% if rabbitmq.config.default_vhost is defined -%}
  default_vhost = {{ rabbitmq.config.default_vhost|default('/') }}
{% endif %}
{% if rabbitmq.config.default_user is defined -%}
  default_user = {{ rabbitmq.config.default_user|default('guest') }}
{% endif %}
{% if rabbitmq.config.default_pass is defined -%}
  default_pass = {{ rabbitmq.config.default_pass|default('guest') }}
{% endif %}

{% if rabbitmq.config.default_permissions is defined %}
default_permissions.configure = {{ rabbitmq.config.default_permissions.configure|default('.*') }}
default_permissions.read      = {{ rabbitmq.config.default_permissions.read|default('.*') }}
default_permissions.write     = {{ rabbitmq.config.default_permissions.write|default('.*') }}
{% endif %}

{% for dict in rabbitmq.config.default_user_tags|default([]) -%}
  {%- for key, value in dict.items() -%}
    default_user_tags.{{key}} = {{value}}
  {% endfor -%}
{%- endfor %}


##
## Additional network and protocol related configuration
## =====================================================
##

## Set the default AMQP 0-9-1 heartbeat interval (in seconds).
## Related doc guides:
##
## * https://rabbitmq.com/heartbeats.html
## * https://rabbitmq.com/networking.html
##
# heartbeat = 60
{% if rabbitmq.config.heartbeat is defined %}
heartbeat = {{ rabbitmq.config.heartbeat|default(60) }}
{% endif %}

## Set the max permissible size of an AMQP frame (in bytes).
##
# frame_max = 131072
{% if rabbitmq.config.frame_max is defined %}
frame_max = {{ rabbitmq.config.frame_max|default(131072) }}
{% endif %}

## Set the max frame size the server will accept before connection
## tuning occurs
##
# initial_frame_max = 4096
{% if rabbitmq.config.initial_frame_max is defined %}
initial_frame_max = {{ rabbitmq.config.initial_frame_max|default(4096) }}
{% endif %}

## Set the max permissible number of channels per connection.
## 0 means "no limit".
##
# channel_max = 128
{% if rabbitmq.config.channel_max is defined %}
channel_max = {{ rabbitmq.config.channel_max|default(128) }}
{% endif %}

## Customising TCP Listener (Socket) Configuration.
##
## Related doc guides:
##
## * https://rabbitmq.com/networking.html
## * https://www.erlang.org/doc/man/inet.html#setopts-2
##

# tcp_listen_options.backlog = 128
# tcp_listen_options.nodelay = true
# tcp_listen_options.exit_on_close = false

# tcp_listen_options.keepalive = true
# tcp_listen_options.send_timeout = 15000

# tcp_listen_options.buffer = 196608
# tcp_listen_options.sndbuf = 196608
# tcp_listen_options.recbuf = 196608

{% if rabbitmq.config.tcp_listen_options is defined %}
tcp_listen_options.backlog = {{ rabbitmq.config.tcp_listen_options.backlog|default(128) }}
tcp_listen_options.nodelay = {{ rabbitmq.config.tcp_listen_options.nodelay|default('true') }}
tcp_listen_options.exit_on_close = {{ rabbitmq.config.tcp_listen_options.exit_on_close|default('false') }}

tcp_listen_options.keepalive = {{ rabbitmq.config.tcp_listen_options.keepalive|default('true') }}
tcp_listen_options.send_timeout = {{ rabbitmq.config.tcp_listen_options.send_timeout|default(15000) }}

tcp_listen_options.buffer = {{ rabbitmq.config.tcp_listen_options.buffer|default(196608) }}
tcp_listen_options.sndbuf = {{ rabbitmq.config.tcp_listen_options.sndbuf|default(196608) }}
tcp_listen_options.recbuf = {{ rabbitmq.config.tcp_listen_options.recbuf|default(196608) }}
{% endif %}


##
## Resource Limits & Flow Control
## ==============================
##
## Related doc guide: https://rabbitmq.com/memory.html.

## Memory-based Flow Control threshold.
##
# vm_memory_high_watermark.relative = 0.4
{% if rabbitmq.config.vm_memory_high_watermark.relative is defined %}
vm_memory_high_watermark.relative = {{ rabbitmq.config.vm_memory_high_watermark.relative|default('0.4') }}
{% endif %}

## Alternatively, we can set a limit (in bytes) of RAM used by the node.
## Or you can set absolute value using memory units (with RabbitMQ 3.6.0+).
## Absolute watermark will be ignored if relative is defined!
##
# vm_memory_high_watermark.absolute = 2GB
##
## Supported unit symbols:
##
## k, kiB: kibibytes (2^10 - 1,024 bytes)
## M, MiB: mebibytes (2^20 - 1,048,576 bytes)
## G, GiB: gibibytes (2^30 - 1,073,741,824 bytes)
## kB: kilobytes (10^3 - 1,000 bytes)
## MB: megabytes (10^6 - 1,000,000 bytes)
## GB: gigabytes (10^9 - 1,000,000,000 bytes)

{% if rabbitmq.config.vm_memory_high_watermark.absolute is defined %}
vm_memory_high_watermark.absolute = {{ rabbitmq.config.vm_memory_high_watermark.absolute|default('2GB') }}
{% endif %}

## Fraction of the high watermark limit at which queues start to
## page message out to disc in order to free up memory.
## For example, when vm_memory_high_watermark is set to 0.4 and this value is set to 0.5,
## paging can begin as early as when 20% of total available RAM is used by the node.
##
## Values greater than 1.0 can be dangerous and should be used carefully.
##
## One alternative to this is to use durable queues and publish messages
## as persistent (delivery mode = 2). With this combination queues will
## move messages to disk much more rapidly.
##
## Another alternative is to configure queues to page all messages (both
## persistent and transient) to disk as quickly
## as possible, see https://rabbitmq.com/lazy-queues.html.
##
# vm_memory_high_watermark_paging_ratio = 0.5
{% if rabbitmq.config.vm_memory_high_watermark_paging_ratio is defined %}
vm_memory_high_watermark_paging_ratio = {{ rabbitmq.config.vm_memory_high_watermark_paging_ratio|default('0.5') }}
{% endif %}

## Selects Erlang VM memory consumption calculation strategy. Can be `allocated`, `rss` or `legacy` (aliased as `erlang`),
## Introduced in 3.6.11. `rss` is the default as of 3.6.12.
## See https://github.com/rabbitmq/rabbitmq-server/issues/1223 and rabbitmq/rabbitmq-common#224 for background.
# vm_memory_calculation_strategy = rss
{% if rabbitmq.config.vm_memory_calculation_strategy is defined %}
vm_memory_calculation_strategy = {{ rabbitmq.config.vm_memory_calculation_strategy|default('rss') }}
{% endif %}

## Interval (in milliseconds) at which we perform the check of the memory
## levels against the watermarks.
##
# memory_monitor_interval = 2500
{% if rabbitmq.config.memory_monitor_interval is defined %}
memory_monitor_interval = {{ rabbitmq.config.memory_monitor_interval|default(2500) }}
{% endif %}

## The total memory available can be calculated from the OS resources
## - default option - or provided as a configuration parameter.
# total_memory_available_override_value = 2GB
{% if rabbitmq.config.total_memory_available_override_value is defined %}
total_memory_available_override_value = {{ rabbitmq.config.total_memory_available_override_value|default('2GB') }}
{% endif %}

## Set disk free limit (in bytes). Once free disk space reaches this
## lower bound, a disk alarm will be set - see the documentation
## listed above for more details.
##
## Absolute watermark will be ignored if relative is defined!
# disk_free_limit.absolute = 50000

## Or you can set it using memory units (same as in vm_memory_high_watermark)
## with RabbitMQ 3.6.0+.
# disk_free_limit.absolute = 500KB
# disk_free_limit.absolute = 50mb
# disk_free_limit.absolute = 5GB

{% if rabbitmq.config.disk_free_limit.absolute is defined %}
disk_free_limit.absolute = {{ rabbitmq.config.disk_free_limit.absolute|default('5GB') }}
{% endif %}

## Alternatively, we can set a limit relative to total available RAM.
##
## Values lower than 1.0 can be dangerous and should be used carefully.
# disk_free_limit.relative = 2.0
{% if rabbitmq.config.disk_free_limit.relative is defined %}
disk_free_limit.relative = {{ rabbitmq.config.disk_free_limit.relative|default('2.0') }}
{% endif %}


##
## Clustering
## =====================
##
# cluster_partition_handling = ignore
{% if rabbitmq.config.cluster_partition_handling is defined %}
cluster_partition_handling = {{ rabbitmq.config.cluster_partition_handling|default('ignore') }}
{% endif %}

## pause_if_all_down strategy require additional configuration
# cluster_partition_handling = pause_if_all_down
{% if rabbitmq.config.cluster_partition_handling.pause_if_all_down is defined %}
cluster_partition_handling = pause_if_all_down
{% elif rabbitmq.config.cluster_partition_handling is defined %}
cluster_partition_handling = {{ rabbitmq.config.cluster_partition_handling }}
{% endif %}

## Recover strategy. Can be either 'autoheal' or 'ignore'
# cluster_partition_handling.pause_if_all_down.recover = ignore
{% if rabbitmq.config.cluster_partition_handling.pause_if_all_down.recover is defined %}
cluster_partition_handling.pause_if_all_down.recover = {{ rabbitmq.config.cluster_partition_handling.pause_if_all_down.recover|default('ignore') }}
{% endif %}

## Node names to check
# cluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@localhost
# cluster_partition_handling.pause_if_all_down.nodes.2 = hare@localhost

{% if rabbitmq.cluster_partition_handling.pause_if_all_down.nodes is defined %}
{% for item in rabbitmq.cluster_partition_handling.pause_if_all_down.nodes %}
cluster_partition_handling.pause_if_all_down.nodes.{{loop.counter}} = {{item}}
{% endfor %}
{% endif %}

## Mirror sync batch size, in messages. Increasing this will speed
## up syncing but total batch size in bytes must not exceed 2 GiB.
## Available in RabbitMQ 3.6.0 or later.
##
# mirroring_sync_batch_size = 4096
{% if rabbitmq.config.mirroring_sync_batch_size is defined %}
mirroring_sync_batch_size = {{ rabbitmq.config.mirroring_sync_batch_size|default(4096) }}
{% endif %}

## Make clustering happen *automatically* at startup. Only applied
## to nodes that have just been reset or started for the first time.
##
## Relevant doc guide: https://rabbitmq.com//cluster-formation.html
##

# cluster_formation.peer_discovery_backend     = rabbit_peer_discovery_classic_config
#
# cluster_formation.classic_config.nodes.1 = rabbit1@hostname
# cluster_formation.classic_config.nodes.2 = rabbit2@hostname
# cluster_formation.classic_config.nodes.3 = rabbit3@hostname
# cluster_formation.classic_config.nodes.4 = rabbit4@hostname

## DNS-based peer discovery. This backend will list A records
## of the configured hostname and perform reverse lookups for
## the addresses returned.

# cluster_formation.peer_discovery_backend = rabbit_peer_discovery_dns
# cluster_formation.dns.hostname = discovery.eng.example.local

{% if rabbitmq.config.cluster_formation is defined %}
{% if rabbitmq.config.cluster_formation.peer_discovery_backend == 'rabbit_peer_discovery_classic_config' %}
cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config
{% for item in rabbitmq.config.cluster_formation.classic_config.nodes %}
cluster_formation.classic_config.nodes.{{loop.index}} = {{item}}
{% endfor %}
{% elif rabbitmq.config.cluster_formation.peer_discovery_backend == 'rabbit_peer_discovery_dns' %}
cluster_formation.peer_discovery_backend = rabbit_peer_discovery_dns
cluster_formation.dns.hostname = {{ rabbitmq.config.cluster_formation.dns.hostname }}
{% endif %}
{% endif %}

## This node's type can be configured. If you are not sure
## what node type to use, always use 'disc'.
# cluster_formation.node_type = disc
{% if rabbitmq.config.cluster_formation.node_type is defined %}
cluster_formation.node_type = {{ rabbitmq.config.cluster_formation.node_type|default('disc') }}
{% endif %}

## Interval (in milliseconds) at which we send keepalive messages
## to other cluster members. Note that this is not the same thing
## as net_ticktime; missed keepalive messages will not cause nodes
## to be considered down.
##
# cluster_keepalive_interval = 10000
{% if rabbitmq.config.cluster_keepalive_interval is defined %}
cluster_keepalive_interval = {{ rabbitmq.config.cluster_keepalive_interval|default(10000) }}
{% endif %}



##
## Statistics Collection
## =====================
##

## Set (internal) statistics collection granularity.
##
## Can be none, coarse or fine
# collect_statistics = none
# collect_statistics = coarse
{% if rabbitmq.config.collect_statistics is defined %}
collect_statistics = {{ rabbitmq.config.collect_statistics }}
{% endif %}

## Statistics collection interval (in milliseconds). Increasing
## this will reduce the load on management database.
##
# collect_statistics_interval = 5000
{% if rabbitmq.config.collect_statistics_interval is defined %}
collect_statistics_interval = {{ rabbitmq.config.collect_statistics_interval|default(5000) }}
{% endif %}

##
## Ra Settings
## =====================
##
## NB: changing these on a node with existing data directory
##     can lead to DATA LOSS.
##
# raft.segment_max_entries = 65536
# raft.wal_max_size_bytes = 1048576
# raft.wal_max_batch_size = 32768
# raft.snapshot_chunk_size = 1000000

{% if rabbitmq.config.raft is defined %}
raft.segment_max_entries = {{ rabbitmq.config.raft.segment_max_entries|default(65536) }}
raft.wal_max_size_bytes  = {{ rabbitmq.config.raft.wal_max_size_bytes|default(1048576) }}
raft.wal_max_batch_size  = {{ rabbitmq.config.raft.wal_max_batch_size|default(32768) }}
raft.snapshot_chunk_size = {{ rabbitmq.config.raft.snapshot_chunk_size|default(1000000) }}
{% endif %}

##
## Misc/Advanced Options
## =====================
##
## NB: Change these only if you understand what you are doing!
##

## Explicitly enable/disable hipe compilation. This option is deprecated
## because HiPE supported has been
## effectively discontinued in Erlang 22.
##
# hipe_compile = false
{% if rabbitmq.config.hipe_compile is defined %}
hipe_compile = {{ rabbitmq.config.hipe_compile|default('false') }}
{% endif %}

## Timeout used when waiting for Mnesia tables in a cluster to
## become available.
##
# mnesia_table_loading_retry_timeout = 30000
{% if rabbitmq.config.mnesia_table_loading_retry_timeout is defined %}
mnesia_table_loading_retry_timeout = {{ rabbitmq.config.mnesia_table_loading_retry_timeout|default(30000) }}
{% endif %}

## Retries when waiting for Mnesia tables in the cluster startup. Note that
## this setting is not applied to Mnesia upgrades or node deletions.
##
# mnesia_table_loading_retry_limit = 10
{% if rabbitmq.config.mnesia_table_loading_retry_limit is defined %}
mnesia_table_loading_retry_limit = {{ rabbitmq.config.mnesia_table_loading_retry_limit|default(10) }}
{% endif %}

## Size in bytes below which to embed messages in the queue index.
## Related doc guide: https://rabbitmq.com/persistence-conf.html
##
# queue_index_embed_msgs_below = 4096
{% if rabbitmq.config.queue_index_embed_msgs_below is defined %}
queue_index_embed_msgs_below = {{ rabbitmq.config.queue_index_embed_msgs_below|default(4096) }}
{% endif %}

## You can also set this size in memory units
##
# queue_index_embed_msgs_below = 4kb
{% if rabbitmq.config.queue_index_embed_msgs_below is defined %}
queue_index_embed_msgs_below = {{ rabbitmq.config.queue_index_embed_msgs_below|default('4kb') }}
{% endif %}

## Whether or not to enable background periodic forced GC runs for all
## Erlang processes on the node in "waiting" state.
##
## Disabling background GC may reduce latency for client operations,
## keeping it enabled may reduce median RAM usage by the binary heap
## (see https://www.erlang-solutions.com/blog/erlang-garbage-collector.html).
##
## Before trying this option, please take a look at the memory
## breakdown (https://www.rabbitmq.com/memory-use.html).
##
# background_gc_enabled = false
{% if rabbitmq.config.background_gc_enabled is defined %}
background_gc_enabled = {{ rabbitmq.config.background_gc_enabled|default('true') }}
{% endif %}

## Target (desired) interval (in milliseconds) at which we run background GC.
## The actual interval will vary depending on how long it takes to execute
## the operation (can be higher than this interval). Values less than
## 30000 milliseconds are not recommended.
##
# background_gc_target_interval = 60000
{% if rabbitmq.config.background_gc_target_interval is defined %}
background_gc_target_interval = {{ rabbitmq.config.background_gc_target_interval|default('60000') }}
{% endif %}

## Whether or not to enable proxy protocol support.
## Once enabled, clients cannot directly connect to the broker
## anymore. They must connect through a load balancer that sends the
## proxy protocol header to the broker at connection time.
## This setting applies only to AMQP clients, other protocols
## like MQTT or STOMP have their own setting to enable proxy protocol.
## See the plugins documentation for more information.
##
# proxy_protocol = false
{% if rabbitmq.config.proxy_protocol is defined %}
proxy_protocol = {{ rabbitmq.config.proxy_protocol|default('false') }}
{% endif %}

## ----------------------------------------------------------------------------
## Advanced Erlang Networking/Clustering Options.
##
## Related doc guide: https://rabbitmq.com/clustering.html
## ----------------------------------------------------------------------------

# ======================================
# Kernel section
# ======================================

## Timeout used to detect peer unavailability, including CLI tools.
## Related doc guide: https://www.rabbitmq.com/nettick.html.
##
# net_ticktime = 60
{% if rabbitmq.config.net_ticktime is defined %}
net_ticktime = {{ rabbitmq.config.net_ticktime|default(60) }}
{% endif %}

## Inter-node communication port range.
## The parameters inet_dist_listen_min and inet_dist_listen_max
## can be configured in the classic config format only.
## Related doc guide: https://www.rabbitmq.com/networking.html#epmd-inet-dist-port-range.


